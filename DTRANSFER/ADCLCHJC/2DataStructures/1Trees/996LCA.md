---
title: 996LCA
---

{% raw %}
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/

node is not present
no duplicate value nodes

```python
void t(TreeNode* node, TreeNode* r1,TreeNode* r2,vector<TreeNode*> &p1, vector<TreeNode*> &p2, vector<TreeNode*> &tmp){
    if(!node) return;
    tmp.push_back(node);

    if(node==r1) p1=tmp;
    if(node==r2) p2=tmp;

    t(node->left,r1,r2,p1,p2,tmp);
    t(node->right,r1,r2,p1,p2,tmp);

    tmp.pop_back();
}

TreeNode* findLCA(vector<TreeNode*> &p1, vector<TreeNode*> &p2){
    //root se lca tak ka path to same rahega
    int idx=0;
    while(idx<p1.size() and idx<p2.size()){
        if(p1[idx]!=p2[idx]) break;
        idx++;
    }
    return p1[idx-1];
}

TreeNode* lowestCommonAncestor(TreeNode* r, TreeNode* r1, TreeNode* r2) {
    vector<TreeNode*> p1,p2,tmp;
    t(r,r1,r2,p1,p2,tmp);
    return findLCA(p1,p2);
}
```

# solution using binary lifting

# Codestorywithmike

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_2DataStructures_1Trees_996LCA__att_0001.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_2DataStructures_1Trees_996LCA__att_0002.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_2DataStructures_1Trees_996LCA__att_0003.png)

# PPA optimized space

If you are standing at a node, and n1 and n2 are present in separate subtrees about that node, then that node is the lca        
if both are in left you will go left n=n->left  ?

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_2DataStructures_1Trees_996LCA__att_0004.png)

```python
Node* findLCA(Node* node, int v1, int v2){
    if(!node) return nullptr;
    if(node->data==v1 or node->data==v2) return node;
    Node* lst=findLCA(node->left,v1,v2);
    Node* rst=findLCA(node->right,v1,v2);
    if(!lst) return rst;
    if(!rst) return lst;
    return node; 
}  
```

# Questions

Min distance between two given nodes of a Binary Tree

https://practice.geeksforgeeks.org/problems/min-distance-between-two-given-nodes-of-a-binary-tree/1

```python
Node* findLCA(Node* n, int v1, int v2){
    if(!n) return NULL;
    if(n->data==v1 or n->data==v2) return n;
    Node* lst=findLCA(n->left,v1,v2);
    Node* rst=findLCA(n->right,v1,v2);
    if(!lst) return rst;
    if(!rst) return lst;
    return n; 
}    


void t(Node* n,int LCA ,int v1, int v2, int &lenLCA, int &lenNode1, int &lenNode2,int lenCurr){
    if(!n) return;
    if(n->data==LCA) lenLCA=lenCurr;
    if(n->data==v1) lenNode1=lenCurr; 
    if(n->data==v2) lenNode2=lenCurr;
    t(n->left,LCA,v1,v2,lenLCA,lenNode1,lenNode2,lenCurr+1);
    t(n->right,LCA,v1,v2,lenLCA,lenNode1,lenNode2,lenCurr+1);        
}


int findDist(Node* root, int v1, int v2) {
    //yaha par jin do nodes ka LCA nikalna hain
    //unki value as a Node dene ke wajae
    //as a value di hain
    int LCA=(findLCA(root,v1,v2))->data;

    //these l are the lengths from root
    int lenLCA=-1,lenNode1=-1,lenNode2=-1,lenCurr=0;
    t(root,LCA,v1,v2,lenLCA,lenNode1,lenNode2,lenCurr);

    return lenNode1-lenLCA + lenNode2-lenLCA;
}
```

# LCA of more then 2 nodes

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_2DataStructures_1Trees_996LCA__att_0005.png)
{% endraw %}
