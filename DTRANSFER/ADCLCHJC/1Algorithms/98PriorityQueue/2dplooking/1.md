---
title: 1
---

{% raw %}
https://leetcode.com/problems/maximum-subsequence-score/description/    
![image.png](/transfernew/notebook_images/transfernew_ADCLCHJC_1Algorithms_98PriorityQueue_2dplooking_1__att_0001.png)

0 <= nums1[i], nums2[j] <= 10^5   
All elements are positive

![image.png](/transfernew/notebook_images/transfernew_ADCLCHJC_1Algorithms_98PriorityQueue_2dplooking_1__att_0002.png)

```python
long long maxScore(vector<int>& v1, vector<int>& v2, int k) {
    int n=v1.size();
    vector<vector<int>> v;
    for(int i=0;i<n;i++){
        v.push_back({v2[i],v1[i]});
    }
    sort(v.begin(),v.end(),greater<vector<int>>());
    long long ans=LLONG_MIN,sum=0;
    priority_queue<int,vector<int>,greater<int>> pq;

    //k-1 elements
    //preparing the first k-1 elements of the array
    for(int i=0;i<=k-2;i++){
        sum+=v[i][1];
        pq.push(v[i][1]);
    }


    for(int i=k-1;i<n;i++){
        sum+=v[i][1];
        pq.push(v[i][1]);
        ans=max(ans,sum*v[i][0]);
        sum-=pq.top();
        pq.pop();
    }
    return ans;
}
```

https://leetcode.com/problems/ipo/description/    
Do it with two pq

![image.png](/transfernew/notebook_images/transfernew_ADCLCHJC_1Algorithms_98PriorityQueue_2dplooking_1__att_0003.png)

summary


by operating at most k transactions

![image.png](/transfernew/notebook_images/transfernew_ADCLCHJC_1Algorithms_98PriorityQueue_2dplooking_1__att_0004.png)

initially w capital

maximise final capital

```python
class Solution {
    public:
        int findMaximizedCapital(int no, int startingCapital, vector<int>& p, vector<int>& c) {
            int n=p.size();
            vector<vector<int>> ma(n);
    
            for(int i=0;i<n;i++){
                ma[i]={c[i],p[i]};
            }
            sort(ma.begin(),ma.end(),[](auto &a, auto &b){
                return a[0]==b[0]?a[1]>b[1]:a[0]<b[0];
            });
            //profits in decreasing order
            //if profits are same: capital in increasing order
    
            //cp
    
            priority_queue<int> pq;
    
            int idx=0;
            int currCapital=startingCapital; 
            while(no--){
                while(idx<n and ma[idx][0]<=currCapital){
                    pq.push(ma[idx][1]);
                    idx++;
                }
    
                if(pq.empty()){
                    //no transactions can be performed
                    break;
                } 
    
                currCapital+=pq.top();
                pq.pop();
            }
            return currCapital;
        }
    
    };
```

too much tc at present, do it with two pq and try to optimize it
{% endraw %}
