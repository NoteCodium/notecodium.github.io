---
title: 1
---

{% raw %}
https://codeforces.com/problemset/problem/1881/E

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0001.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0002.png)

if removing nothing is helping you have to remove the whole array

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0003.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0004.png)

unintuitive

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0005.png)

now makes sense

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0006.png)

dp

breaking the problems into smaller subproblems

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0007.png)

overlapping sub problems     
![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0008.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0009.png)

ans=n-dp[0]

base case     
dp[n-1]=0

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0010.png)

standing on an element you can either take that element or skip that element

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0011.png)

but it is not necessary that the second condition of picking the element is always true., there can be less elements behind it then the picked up element

telling a problem is from dp     
1. Seeing divide and conquer happening or not
2. Seeing overlapping subproblems

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0012.png)

https://codeforces.com/problemset/problem/1714/D

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0013.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0014.png)

but there is a catch

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0015.png)

we just cant stop caring about c, or the other read characters, but in this way our problem will not be ever solved. so, 1 char we dont care

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0016.png)

these 3 subproblems are diffferent

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0017.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0018.png)

ans=dp[0][0]

if non of the character matches with ith red colored, then we can move to i+1 th character

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0019.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-3HawaHeenNaLage_1__att_0020.png)

```python
i+k-1<=n-1
i+k<=n
k<=n-i

if
k>n-i
dp[i][k]=inf
```

```python
i+k-1=n-1
k=n-i
all the remaining characters are colored
dp[i][k]=0
```

```
dp[i][k]=min(pick,skip);
skip=dp[i+1][k-1]
pick=inf;
for(string t: vos){
    len=t.size();
    if(i+len-1<=n-1 and s.substr(i,len)==t){
        pick=min(pick,dp[i+1][max(k-1, len-1)]);
    }
}

dp[i][k]=min(pick,skip);
```
{% endraw %}
