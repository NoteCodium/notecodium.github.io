![image.png](1_images/image.png)    
Same as recursive approach


```python
vector<int> mergeKArrays(vector<vector<int>> &ma, int n){
    vector<vector<int>> v;
    for(int i=0;i<n;i++) v.push_back({i,0});
    auto cmp=[&](auto &a ,auto &b){
        int x=ma[a[0]][a[1]],y=ma[b[0]][b[1]];
        return x>y;
    };
    priority_queue<vector<int> ,vector<vector<int>>,decltype(cmp)> pq(cmp,v);
    vector<int> ans;
    while(!pq.empty()){
        auto p=pq.top();
        pq.pop();
        int i=p[0],j=p[1];
        ans.push_back(ma[i][j]);
        if(j+1<n) pq.push({i,j+1});
    }
    return ans;
}

```

```python

struct cmp{ 
    bool operator()(auto &a, auto &b){ 
        int x=gm[a.first][a.second],y=gm[b.first][b.second];
        return x>y;
    } 
};


vector<int> mergeKArrays(vector<vector<int>> ma, int n){
    gm= ma;
    vector<pair<int,int>> v;
    for(int i=0;i<n;i++) v.push_back({i,0});
    priority_queue<pair<int,int> ,vector<pair<int,int>>,cmp> pq(v.begin(),v.end());
    vector<int> ans;
    while(pq.size()){
        pair<int,int> p=pq.top();pq.pop();
        int i=p.first,j=p.second;
        ans.push_back(ma[i][j]);
        if(j+1<n) pq.push({i,j+1});
    }
    return ans;
    
}
```
