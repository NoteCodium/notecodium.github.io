# Kruskal's Algorithm


1. sort all the edges by their weights
2. union


https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1


al is like every node have a vvi, each vector containing {node, weight}


```python
int spanningTree(int n, vector<vector<int>> al[])
{   
    vector<vector<int>> edges;
    for(int i=0;i<n;i++){
        for(auto v: al[i]){
            edges.push_back({i,v[0],v[1]});
        }
    }
    sort(edges.begin(),edges.end(), [](vector<int> &a, vector<int> &b){
        return a[2]<b[2];
    });

    dsu d(n);
    int ans=0;
    for(auto edge: edges){
        int wt=edge[2];
        int u=edge[0];
        int v=edge[1];
        if(!d.sameRoot(u,v)){
            ans+=wt;
            d.union_(u,v);
        }
    }
    return ans;
}


class dsu{
    public: 
          vector<int> par,size;
          dsu(int n){
              for(int i=0;i<n;i++){
                  par.push_back(i);
                  size.push_back(1);
              }
          }
        
        int find(int node){
            if(par[node]==node) return node;
            return par[node]=find(par[node]);
        }
        
        bool sameRoot(int i, int j){
            return find(i)==find(j);
        }
        
        void union_(int i, int j){
            if(sameRoot(i,j)) return;
            int rooti=find(i),rootj=find(j);
            int sizei=size[rooti],sizej=size[rootj];
            if(size[rooti]<size[rootj]) swap(rooti,rootj);
            par[rootj]=rooti;
            size[rooti]+=size[rootj];
        }
        
      
    };
```

# Prims Algorithm


does not use DSU

