https://leetcode.com/problems/house-robber/description/  

adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.


```python
class Solution {
    public:
        int f(int idx,  vector<int> &v, vector<int> &mem){
            if(idx<0) return 0;
            if(idx==0) return v[0];
            if(mem[idx]!=-1) return mem[idx];
            return mem[idx]=max(f(idx-2,v,mem)+v[idx],f(idx-1,v,mem));
        }
    
        int rob(vector<int>& v){
            int n=v.size();
            vector<int> mem(n,-1);
            return f(n-1,v,mem);
        }
    };
```

```python
class Solution {
    public:
        int rob(vector<int>& v){
            int n=v.size();
            vector<int> dp(n+1);
            dp[0]=0;
            dp[1]=v[0];
            for(int i=2;i<=n;i++){
                dp[i]=max(dp[i-2]+v[i-1],dp[i-1]);
            }
            return dp[n];
        }
    };
```

# Another way of solving to reinforce your concepts



```python
dp[i][0]== maximum sum if we dont pick the ith element
dp[i][1]= if we pick the ith element
```

0 based indexing


we now dont need array of size n+1


```python
//base conditions
dp[0][0]=0
dp[0][1]=v[0]
```

```python
//transitions
dp[i][0]=max(dp[i-1][1],dp[i-1][0])
dp[i][1]=v[i] + dp[i-1][0];
```

```python
//Answer
max(dp[n-1][1],dp[n-1][0])
```

```python
int rob(vector<int>& v) {
    int n=v.size();
    vector<vector<int>> dp(n,vector<int>(2));
    dp[0][0]=0;
    dp[0][1]=v[0];
    for(int i=1;i<n;i++){
        dp[i][0]=max(dp[i-1][1],dp[i-1][0]);
        dp[i][1]=dp[i-1][0]+v[i];
    }
    return max(dp[n-1][0],dp[n-1][1]);
}
```
