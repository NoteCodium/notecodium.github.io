https://codeforces.com/problemset/problem/1350/B


# B. Orac and Models


dp[i][j]= standing at idx i such that last element is j


![image.png](2_images/image.png)


The answer from here for both the series will be the same.


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


```python
void solve(){   
    ll lastElem,len;
    inp(lastElem,len);
    //dp state 
    //dp[len][lastElement]
    //base case
    //dp[n][anyValue]=1
    ///answer 
    //dp[0][1]
    //putting a 1 at an invalid idx insures that
    //the first actual index can take any value
    //as all elements are multiple of 1
    vvl dp(len+1,vl(lastElem+1));
    for(ll i=1;i<=lastElem;i++){
        dp[len][i]=1;
    }
    for(int i=len-1;i>=0;i--){
        for(int j=1;j<=lastElem;j++){
            for(int k=j;k<=lastElem;k+=j){
                dp[i][j]=moda(dp[i][j],dp[i+1][k]);
            }
        } 
    }
    pri(dp[0][1]);
}
```

https://cses.fi/problemset/task/1746


# Array Description


![image.png](2_images/image.png)


![image.png](2_images/image.png)


overlapping subproblems    
![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


![image.png](2_images/image.png)


writing transitions


![image.png](2_images/image.png)


![image.png](2_images/image.png)


```python
int main()  
{
    ll n,limit;
    cin>>n>>limit;
    vfirst(v,n);
    vector<vector<long long>> dp(n,vector<long long> (limit+1,0));
    //dp[idx][x]
    //standing at idx idx and x is the value at idx
 
    //base case
    for(int i=1;i<=limit;i++){
        dp[0][i]= v[0]==0 or v[0] ==i ? 1:0;
    }
 
    //we are only considering prefixes as of now
 
    for(int i=1;i<n;i++){
        for(int j=1;j<=limit;j++){
            //doubt
            if(v[i]==0 or v[i]==j){
                dp[i][j] = dp[i - 1][j];
                if (j - 1 >= 0)
                    dp[i][j] = moda(dp[i - 1][j - 1],dp[i][j]);
                if (j + 1 <= limit)
                    dp[i][j] = moda(dp[i - 1][j + 1],dp[i][j]);
            }
        }
    }
 
    ll ans=0;
    for(int i=1;i<=limit;i++){
        ans=moda(ans,dp[n-1][i]);
    }
 
    cout<<ans<<nl;
 
 
}
```
