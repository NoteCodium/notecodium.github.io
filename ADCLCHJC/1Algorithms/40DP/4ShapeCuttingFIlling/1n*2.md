https://www.geeksforgeeks.org/problems/ways-to-tile-a-floor5836/1


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


```python
class Solution {
    public:
    
  #define mod 1000000007
  #define moda(a,b) ((a%mod)+(b%mod))%mod 
    
    long long solve(long long n,vector<int> &mem)
    {
      if(n==0) return 1;
      if(n<0) return 0;     
      if(mem[n]!=-1) return mem[n];
      return mem[n]=moda(solve(n-1,mem),solve(n-2,mem));
    }
    
      long long numberOfWays(long long n) 
      {
          vector<int> mem(n+1,-1);
          return solve(n,mem);
      }
  };
```

https://cses.fi/problemset/task/2413


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


they are separate


![image.png](1n*2_images/image.png)


high chances you precompute the answer and then for every tc just print the answer


![image.png](1n*2_images/image.png)


only a vertical cell can be filled here


![image.png](1n*2_images/image.png)


both are closed 


![image.png](1n*2_images/image.png)


both are growing


![image.png](1n*2_images/image.png)


one column is growing 


we dont care where the blocks started, we just care about the blocks are growing or not


if there are two growing blocks, we can do thigs     
1. allow them to grow
2. stop them


![image.png](1n*2_images/image.png)


when stopped on the left, we have to start a new vertical block


![image.png](1n*2_images/image.png)


we can insert a horizontal block only when both vertical growing blocks are ending 


the whole horizontal cell can also be allowed to extend 


![image.png](1n*2_images/image.png)


the horizontal row started from i-1th row


![image.png](1n*2_images/image.png)


in the end we have to close any how


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


a little doubty 


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


dp[i] ======= no of filling i till n rows

Final subproble

dp[0][0]+ dp[0][1]


```python
vvl dp(1e6+1,vl(2));
void solve(){
    iinp(n);
    dp[n-1][0]=dp[n-1][1]=1;
    for(int i=n-2;i>=0;i--){
        dp[i][0]=dp[i+1][0]+dp[i+1][1]+dp[i+1][0]+2*dp[i+1][0];
        dp[i][0]%=mod;
        dp[i][1]=2*dp[i+1][1]+dp[i+1][0];
        dp[i][1]%=mod;
    }
    print((dp[0][0]+dp[0][1])%mod);
}
```

https://leetcode.com/problems/domino-and-tromino-tiling/description/


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


n=4


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


addition of some constant bhi hona chahhiye


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


to remove the duplicacy       
https://youtu.be/Iwmn-gFL3c0?si=grxVA9pTCxwix0dZ


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


some dulicates again on normal dinamos


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


Now we got a pattern


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


recursion    
![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


# The actual solution


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


?


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


https://youtu.be/CecjOo4Zo-g?si=5UtGdItmCL1M_dKT


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


![image.png](1n*2_images/image.png)


```python
#define MOD 1000000007
class Solution {
public:

    int makeState(bool t1, bool t2){
        if(!t1 and !t2){
          return 0;              
        }
        if(t1 and !t2){
          return 1;              
        }
        if(!t1 and t2){
          return 2;              
        }
        return 3;
    }

    int f(int idx, bool t1, bool t2, vector<vector<int>> &mem, int n){
        if(idx>=n){
            return 1;
        }
        int state=makeState(t1,t2);
        if(mem[idx][state]!=-1){
            return mem[idx][state];
        }
        bool t3=idx+1<n, t4=idx+1<n;
        long count=0;
        // Placing:
        // XX
        // X
        if (t1 && t2 && t3) count += f(idx + 1, false, true,mem,n);

        // Placing:
        // X
        // XX
        if (t1 && t2 && t4) count += f(idx + 1, true, false,mem,n);

        // Placing:
        // XX
        // #X
        if (t1 && !t2 && t3 && t4) count += f(idx + 1, false, false,mem,n);

        // Placing:
        // #X
        // XX
        if (!t1 && t2 && t3 && t4) count += f(idx + 1, false, false,mem,n);

        // Placing
        // X
        // X
        if (t1 && t2) count += f(idx + 1, true, true,mem,n);

        // Placing two horizontals. We don't place 2 verticals because
        // that's accounted for with the single vertical tile:
        // XX
        // XX
        if (t1 && t2 && t3 && t4) count += f(idx + 1, false, false,mem,n);

        // Placing:
        // XX
        // #
        if (t1 && !t2 && t3) count += f(idx + 1, false, true,mem,n);

        // Placing:
        // #
        // XX
        if (!t1 && t2 && t4) count += f(idx + 1, true, false,mem,n);

        // Current column is already fully tiled, so move to next column
        // #
        // #
        if (!t1 && !t2) count += f(idx + 1, true, true,mem,n);

        return mem[idx][state] = count % (long)MOD;

    }

    int numTilings(int n) {
        vector<vector<int>> mem(n,vector<int>(4,-1));
        return f(0,1,1,mem,n);
        //f(i): no of possibilities from i to n-1
    }
};
```
