<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>{{ page.title }}</title>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

  <style>
    /* Prevent FOUC during auth check */
    body {
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
  <script>
    // --- Client-Side Auth Gate ---
    // --- Client-Side Auth Gate ---
    (function () {
      // Configuration from _data/auth.yml
      const authEnabled = {{ site.data.auth.enabled | default: false
    }};

    if (!authEnabled) {
      // Auth is disabled - Show content immediately
      document.addEventListener("DOMContentLoaded", () => {
        document.body.style.visibility = 'visible';
        document.body.style.opacity = '1';
      });
      return;
    }

    const isAuth = localStorage.getItem('notecodium_auth');
    const isLoginPage = window.location.pathname.endsWith('/login.html');

    // If not authenticated and not on login page, redirect
    if (!isAuth && !isLoginPage) {
      window.location.href = '/login.html';
    } else {
      // Authenticated or on login page - show content
      document.addEventListener("DOMContentLoaded", () => {
        document.body.style.visibility = 'visible';
        document.body.style.opacity = '1';
      });
    }
    }) ();
  </script>

  <style>
    /* 1. Global Resets */
    :root {
      --sidebar-bg: #e0e0e0;
      --sidebar-border: #d0d7de;
      --text-color: #24292e;
      --link-color: #0969da;
      --bg-color: #ffffff;
      --base-font-size: 16px;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      /* Remove default margin so sidebar touches edge */
      padding: 0;
      background: var(--bg-color);
      color: var(--text-color);
      font-size: var(--base-font-size);
      padding-bottom: 60px;
      /* Space for footer */
    }

    /* Text Size Slider Footer */
    .text-size-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background-color: rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      padding: 0 20px;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.03);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      z-index: 1000;
      box-sizing: border-box;
    }

    .text-size-footer input[type=range] {
      width: 200px;
      cursor: pointer;
    }

    .reset-btn {
      padding: 5px 10px;
      font-size: 12px;
      background-color: #f6f8fa;
      border: 1px solid #d0d7de;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }

    .reset-btn:hover {
      background-color: #eef1f4;
    }

    .nav-btn {
      padding: 5px 12px;
      font-size: 12px;
      background-color: #f6f8fa;
      border: 1px solid #d0d7de;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-color);
      transition: background-color 0.2s;
    }

    .nav-btn:hover {
      background-color: #eef1f4;
    }

    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .nav-btn:disabled:hover {
      background-color: #f6f8fa;
    }

    /* Adjust sidebar height to not overlap footer */
    .sidebar {
      height: calc(100vh - 50px);
    }

    /* 2. The Layout Container (Flexbox) */
    .page-container {
      display: flex;
      min-height: 100vh;
    }

    /* 3. The Sidebar (Fixed on Left) */
    .sidebar {
      width: 280px;
      /* Fixed width */
      background-color: var(--sidebar-bg);
      /* Slightly darker background */
      border-right: 1px solid var(--sidebar-border);
      padding: 0;
      /* Remove padding from parent, moved to content */
      flex-shrink: 0;
      /* Prevent shrinking */

      /* Sticky behavior */
      position: sticky;
      top: 0;
      height: 100vh;
      /* Full height */
      display: flex;
      flex-direction: row;
      overflow: hidden;
      /* No scroll on parent */
      font-size: 0.9em;
    }

    .sidebar-content {
      flex: 1;
      height: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      padding-bottom: 150px;
    }

    .sidebar-resizer {
      width: 5px;
      /* Reduce dead zone for scrolling */
      cursor: col-resize;
      background-color: transparent;
      flex-shrink: 0;
      /* height: 100%; REMOVED, flex handles height */
      /* position: absolute; REMOVED to prevent overlap with scrollbar */
      /* right: 0; */
      /* top: 0; */
      z-index: 100;
      transition: background-color 0.2s;
    }

    .sidebar-resizer:hover,
    .sidebar-resizer.resizing {
      background-color: var(--link-color);
    }

    /* 4. The Main Content Area */
    .content {
      flex-grow: 1;
      /* Take remaining width */
      padding: 40px;
      max-width: 100%;
      /* User requested full width */
      /* No margin: auto here because flex handles the layout */
      min-width: 0;
      /* Important for flex truncation */
    }

    .content img {
      max-width: 100%;
      height: auto;
    }

    /* Custom Code Block Styles */
    pre code.hljs {
      background-color: #e1e4e8 !important;
      /* Darker gray for prominence */
      border-radius: 6px;
      padding: 1rem;
    }

    /* 5. Your Existing Styles (Applied globally) */
    ul {
      list-style: none;
      padding-left: 20px;
      margin: 0;
    }

    li {
      margin: 6px 0;
    }

    a {
      text-decoration: none;
      color: var(--link-color);
    }

    a:hover {
      text-decoration: underline;
    }

    /* Optional: Style the Summary (Folder Name) */
    summary {
      outline: none;
      margin-bottom: 5px;
      color: var(--text-color);
    }

    /* 6. Sidebar Toggle & Collapsed State */
    .sidebar-toggle {
      position: fixed;
      left: 20px;
      top: 15px;
      z-index: 1000;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color);
      padding: 0 5px;
      transition: left 0.1s;
    }

    body.sidebar-collapsed .sidebar {
      display: none;
    }

    body.sidebar-collapsed .content {
      padding-left: 60px;
      /* Space for the toggle button when sidebar is gone */
    }

    /* Move toggle button when sidebar is visible */
    body:not(.sidebar-collapsed) .sidebar-toggle {
      position: fixed;
      left: 240px;
      /* Will be updated by JS */
      top: 15px;
    }

    /* Collapse button - sticky */
    .sidebar-actions {
      position: sticky;
      top: 0;
      background-color: rgba(224, 224, 224, 0.4);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      z-index: 10;
      padding: 10px 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .collapse-btn {
      width: 100%;
      padding: 8px 12px;
      font-size: 0.8rem;
      background-color: var(--bg-color);
      border: 1px solid var(--sidebar-border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-color);
      transition: background-color 0.2s;
    }

    .collapse-btn:hover {
      background-color: #f0f0f0;
    }
  </style>
</head>

<body>

  <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle Sidebar">‚ò∞</button>

  <div class="page-container">

    <nav class="sidebar" id="sidebar">
      <div class="sidebar-content">

        {% include sidebar_fast.html %}
      </div>
      <div class="sidebar-resizer" id="sidebarResizer"></div>
    </nav>

    <main class="content">
      {{ content }}
    </main>

  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const toggleBtn = document.getElementById("sidebarToggle");
      const body = document.body;
      const sidebar = document.getElementById("sidebar");
      const sidebarContent = sidebar.querySelector('.sidebar-content');
      const resizer = document.getElementById("sidebarResizer");
      const collapseAllBtn = document.getElementById("collapseAllBtn");
      const STORAGE_KEY = "sidebar_collapsed";
      const WIDTH_KEY = "sidebar_width";
      const SCROLL_KEY = "sidebar_scroll_position";
      const DEFAULT_WIDTH = 280;

      // --- Helper Functions ---
      function updateTogglePosition(width) {
        if (!body.classList.contains("sidebar-collapsed")) {
          // Position near right edge: width - approx 40px
          toggleBtn.style.left = (width - 40) + "px";
        } else {
          toggleBtn.style.left = "20px";
        }
      }

      function setSidebarWidth(width) {
        sidebar.style.width = width + "px";
        updateTogglePosition(width);
      }

      // --- 1. Restore State ---
      // Width
      let savedWidth = parseInt(localStorage.getItem(WIDTH_KEY));
      if (!savedWidth || isNaN(savedWidth)) savedWidth = DEFAULT_WIDTH;
      setSidebarWidth(savedWidth);

      // Collapsed
      if (localStorage.getItem(STORAGE_KEY) === "true") {
        body.classList.add("sidebar-collapsed");
        updateTogglePosition(savedWidth); // Resets to 20px
      } else {
        updateTogglePosition(savedWidth);
      }

      // Scroll Position (Applied to sidebar-content now)
      const savedScroll = localStorage.getItem(SCROLL_KEY);
      if (savedScroll) {
        sidebarContent.scrollTop = parseInt(savedScroll, 10);
      }

      // --- 2. Event Listeners ---

      // Toggle
      toggleBtn.addEventListener("click", function () {
        body.classList.toggle("sidebar-collapsed");
        const isCollapsed = body.classList.contains("sidebar-collapsed");
        localStorage.setItem(STORAGE_KEY, isCollapsed);

        // Update position immediately
        const currentWidth = parseInt(sidebar.style.width, 10) || DEFAULT_WIDTH;
        updateTogglePosition(currentWidth);
      });



      // --- Debounce Helper ---
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      // Scroll Persistence (Debounced)
      sidebarContent.addEventListener("scroll", debounce(function () {
        localStorage.setItem(SCROLL_KEY, sidebarContent.scrollTop);
      }, 200));

      // --- 3. Drag Logic ---
      let isResizing = false;

      resizer.addEventListener('mousedown', (e) => {
        console.log("Resizer mousedown triggered");
        isResizing = true;
        resizer.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none'; // Prevent text selection
        e.preventDefault(); // Stop default behavior
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        // Calculate new width
        let newWidth = e.clientX;
        console.log("Resizing to:", newWidth);

        // Constraints
        if (newWidth < 150) newWidth = 150;
        if (newWidth > window.innerWidth - 100) newWidth = window.innerWidth - 100;

        setSidebarWidth(newWidth);
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          console.log("Resizer mouseup triggered");
          isResizing = false;
          resizer.classList.remove('resizing');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';

          // Save
          const currentWidth = parseInt(sidebar.style.width, 10);
          localStorage.setItem(WIDTH_KEY, currentWidth);
        }
      });
    });
  </script>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
  <script>
    // Define helper functions globally
    window.highlightCode = function () {
      document.querySelectorAll('pre code').forEach((el) => {
        el.className = 'language-cpp';
        hljs.highlightElement(el);
      });
    };

    window.autoLinkContent = function () {
      const content = document.querySelector('.content');
      if (!content) return;

      const walker = document.createTreeWalker(
        content,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: function (node) {
            if (['A', 'SCRIPT', 'STYLE', 'PRE', 'CODE', 'TEXTAREA'].includes(node.parentNode.tagName)) {
              return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      );

      const nodes = [];
      let node;
      while (node = walker.nextNode()) nodes.push(node);

      // Regex for HTTP/HTTPS URLs
      const urlRegex = /https?:\/\/[^\s<"']+/g;

      nodes.forEach(node => {
        const text = node.nodeValue;
        if (text.indexOf('http') === -1) return;

        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;

        urlRegex.lastIndex = 0;

        while ((match = urlRegex.exec(text)) !== null) {
          const url = match[0];
          const cleanUrl = url.replace(/[.,)\]]+$/, '');

          fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));

          const a = document.createElement('a');
          a.href = cleanUrl;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = cleanUrl;
          fragment.appendChild(a);

          const stripped = url.substring(cleanUrl.length);
          if (stripped) {
            fragment.appendChild(document.createTextNode(stripped));
          }

          lastIndex = match.index + url.length;
        }

        if (lastIndex > 0) {
          if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
          }
          node.parentNode.replaceChild(fragment, node);
        }
      });
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      window.highlightCode();
      window.autoLinkContent();
    });
  </script>
  <div class="text-size-footer">
    <style>
      .text-size-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
        padding: 10px;
      }

      .footer-section {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      /* Range Slider */
      #textSizeSlider {
        width: 80px;
      }

      /* Toggle Switch */
      .switch {
        position: relative;
        display: inline-block;
        width: 34px;
        height: 18px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #2196F3;
        transition: .4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }

      input:checked+.slider {
        background-color: #4CAF50;
      }

      input:checked+.slider:before {
        transform: translateX(16px);
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .text-size-footer {
          flex-direction: column;
          align-items: stretch;
          height: auto !important;
          padding-bottom: 20px;
        }

        .footer-section {
          justify-content: space-between;
          width: 100%;
          flex-wrap: wrap;
        }

        .footer-center {
          justify-content: center;
        }

        #fuzzy-search-input {
          flex-grow: 1;
        }

        button {
          padding: 8px 12px;
          /* Bigger touch targets */
        }
      }
    </style>

    <div class="text-size-footer">
      <!-- Left: Search & Tree -->
      <div class="footer-section footer-left">
        <button id="footerCollapseBtn" class="reset-btn" title="Collapse All Folders"
          style="font-size: 16px;">üìÇ</button>
        <input type="text" id="fuzzy-search-input" placeholder="Search..."
          style="padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
        <div id="search-stats" style="font-size: 10px; color: #666; white-space: nowrap;"></div>
      </div>

      <!-- Center: Content Controls -->
      <div class="footer-section footer-center">
        <!-- Font Size -->
        <div style="display: flex; align-items: center; gap: 5px;">
          <span style="font-size: 12px; font-weight: bold;">A</span>
          <input type="range" id="textSizeSlider" min="12" max="28" value="16" step="1">
          <span style="font-size: 24px; font-weight: bold;">A</span>
        </div>

        <!-- Actions -->
        <button id="resetTextSize" class="reset-btn" title="Reset Font">Default</button>

        <button id="editGithubBtn" class="reset-btn"
          style="background-color: #e3f2fd; color: #0d47a1; border-color: #2196f3;">
          GitHub
        </button>

        <button id="editCodespaceBtn" class="reset-btn"
          style="background-color: #e8f5e9; color: #1b5e20; border-color: #4caf50;" title="Edit in VS Code">
          VS Code
        </button>

        <button id="offlineBtn" class="reset-btn"
          style="background-color: #f3e5f5; color: #4a148c; border-color: #ce93d8;" title="Manage Offline Content">
          üì• Offline
        </button>

        <!-- Image Toggle -->
        <div
          style="display: flex; align-items: center; border-left: 1px solid #ddd; padding-left: 10px; margin-left: 5px;">
          <span style="font-size: 11px; color: #666; margin-right: 5px;">Img:</span>
          <label class="switch">
            <input type="checkbox" id="imgSourceToggle">
            <span class="slider round"></span>
          </label>
          <span id="imgSourceLabel" style="font-size: 11px; color: #666; margin-left: 5px; width: 40px;">Local</span>
        </div>
      </div>

      <!-- Right: Navigation -->
      <div class="footer-section footer-right">
        <button id="backBtn" class="nav-btn" title="Previous Page">‚Üê Back</button>
        <button id="nextBtn" class="nav-btn" title="Next Page">Next ‚Üí</button>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // --- Image Source Toggle Logic ---
        const imgToggle = document.getElementById('imgSourceToggle');
        const imgLabel = document.getElementById('imgSourceLabel');
        const IMG_KEY = 'use_hosted_images';

        // 1. Restore State
        const isHosted = localStorage.getItem(IMG_KEY) === 'true';
        imgToggle.checked = isHosted;
        updateLabel(isHosted);
        updateImageSource(isHosted);

        // 2. Listener
        imgToggle.addEventListener('change', function () {
          const checked = this.checked;
          localStorage.setItem(IMG_KEY, checked);
          updateLabel(checked);

          // Placeholder for future logic
          updateImageSource(checked);
        });

        const MAP_URL = '/assets/image_map.json';
        let imageMap = null;

        async function getImageMap() {
          if (imageMap) return imageMap;
          try {
            // Add timestamp to bypass Service Worker cache for this specific data file
            const res = await fetch(MAP_URL + '?t=' + Date.now());
            if (!res.ok) throw new Error("Map not found");
            imageMap = await res.json();
            return imageMap;
          } catch (e) {
            console.warn("Could not load image map:", e);
            return {};
          }
        }

        function updateLabel(isHosted) {
          imgLabel.textContent = isHosted ? "Hosted" : "Local";
        }

        function normalizePath(path) {
          // Remove runs of slashes
          path = path.replace(/\/+/g, '/');

          // Handle '..' segments (basic implementation)
          const parts = path.split('/');
          const stack = [];
          for (const part of parts) {
            if (part === '..') stack.pop();
            else if (part !== '.') stack.push(part);
          }
          let normalized = stack.join('/');

          // Ensure leading slash
          if (!normalized.startsWith('/')) normalized = '/' + normalized;
          return normalized;
        }

        async function updateImageSource(isHosted) {
          console.log("Image Source Changed:", isHosted ? "Hosted" : "Local");

          if (isHosted) {
            const map = await getImageMap();
            const images = document.querySelectorAll('img');

            images.forEach(img => {
              let src = img.getAttribute('src');
              if (!src) return;

              // Normalize the path to match the map keys (which are always /images/...)
              // If src is "../images/foo.png", we want "/images/foo.png"
              // If src is "/images/foo.png", we want "/images/foo.png"

              let lookupKey = src;
              if (!lookupKey.startsWith('http')) {
                // If it contains '..', try to resolve it relative to the root, assuming /images/ is the base
                if (lookupKey.includes('..')) {
                  // A more robust solution would involve knowing the current page's path
                  // For now, we'll assume image paths are relative to the site root or /images/
                  const currentPath = window.location.pathname;
                  const baseUrl = currentPath.substring(0, currentPath.lastIndexOf('/'));

                  // Create a dummy URL to resolve relative paths
                  const absoluteUrl = new URL(src, window.location.origin + baseUrl + '/').pathname;
                  lookupKey = normalizePath(absoluteUrl);
                } else if (!lookupKey.startsWith('/')) {
                  // If it doesn't start with '/' and isn't 'http', prepend '/'
                  lookupKey = '/' + lookupKey;
                }
              }

              // Ensure lookupKey is normalized (e.g., no double slashes)
              lookupKey = normalizePath(lookupKey);

              if (map[lookupKey]) {
                // The map entry is now an object: { url: "...", provider: "...", ... }
                // Backwards compatibility check (if it's a string vs object)
                const cloudUrl = typeof map[lookupKey] === 'string' ? map[lookupKey] : map[lookupKey].url;

                // Save original if not already saved
                if (!img.dataset.originalSrc) {
                  img.dataset.originalSrc = src;
                }

                if (cloudUrl) {
                  img.src = cloudUrl;
                }
              }
            });
          } else {
            // Revert to local
            const images = document.querySelectorAll('img[data-original-src]');
            images.forEach(img => {
              img.src = img.dataset.originalSrc;
            });
          }
        }


        const textSizeSlider = document.getElementById('textSizeSlider');
        const SIZE_KEY = "user_font_size";

        // 1. Restore State
        const savedSize = localStorage.getItem(SIZE_KEY);
        if (savedSize) {
          document.documentElement.style.setProperty('--base-font-size', savedSize + 'px');
          textSizeSlider.value = savedSize;
        }

        // 2. Listener
        textSizeSlider.addEventListener('input', function () {
          const newVal = this.value;
          document.documentElement.style.setProperty('--base-font-size', newVal + 'px');
          localStorage.setItem(SIZE_KEY, newVal);
        });

        // 3. Reset Button
        document.getElementById('resetTextSize').addEventListener('click', function () {
          const defaultSize = 16;
          document.documentElement.style.setProperty('--base-font-size', defaultSize + 'px');
          textSizeSlider.value = defaultSize;
          localStorage.setItem(SIZE_KEY, defaultSize);
        });

        // 4. Collapse All Button
        const collapseBtn = document.getElementById('footerCollapseBtn');
        if (collapseBtn) {
          collapseBtn.addEventListener('click', function () {
            // Select all details in the sidebar
            const allDetails = document.querySelectorAll('.sidebar-content details');
            allDetails.forEach(detail => {
              // Check if it is a root folder (direct child of .file-tree)
              const isRoot = detail.parentElement.parentElement.classList.contains('file-tree');

              // Option: Collapse everything that isn't the main list wrapper
              if (detail.hasAttribute('open') && !isRoot) {
                detail.removeAttribute('open');
                if (detail.id) localStorage.removeItem(detail.id);
              }
            });
          });
        }
      });
    </script>
    <!-- Editor Overlay -->


    <script>
      // Codespace Configuration - Loaded from _data/codespace.yml
      window.CODESPACE_CONFIG = {
        defaultCodespaceName: "{{ site.data.codespace.codespace_name | default: 'ominous-train-97w54wjg45wghp975' }}",
        repoName: "{{ site.data.codespace.repo_name | default: 'notecodium.github.io' }}",
        githubUsername: "{{ site.data.codespace.github_username | default: 'notecodium' }}",
        branch: "{{ site.data.codespace.branch | default: 'main' }}",
        autoDetect: {{ site.data.codespace.auto_detect | default: true }},
      localWorkspacePath: "{{ site.data.codespace.local_workspace_path | default: '/Users/tarunmac/Developer' }}"
    };

      document.addEventListener("DOMContentLoaded", function () {
        const editGithubBtn = document.getElementById('editGithubBtn');
        const editCodespaceBtn = document.getElementById('editCodespaceBtn');
        // Liquid variable for current path
        const currentPath = "{{ page.path }}";
        // GitHub Repo Details (using data file values)
        const githubUsername = "{{ site.data.codespace.github_username | default: 'notecodium' }}";
        const githubRepo = "{{ site.data.codespace.repo_name | default: 'notecodium.github.io' }}";
        const branch = "{{ site.data.codespace.branch | default: 'main' }}";

        if (editGithubBtn) {
          editGithubBtn.addEventListener('click', function () {
            // Open GitHub Editor in new tab
            // Format: https://github.com/[user]/[repo]/edit/[branch]/[path]
            const githubUrl = `https://github.com/${githubUsername}/${githubRepo}/edit/${branch}/${currentPath}`;
            window.open(githubUrl, '_blank');
          });
        }

        if (editCodespaceBtn) {
          editCodespaceBtn.addEventListener('click', function () {
            // Use global configuration
            const config = window.CODESPACE_CONFIG;
            let codespaceName = config.defaultCodespaceName;

            // Try to detect codespace name from various sources (if auto-detect is enabled)
            if (config.autoDetect) {
              if (window.location.hostname.includes('github.dev')) {
                // Extract from github.dev URL if available
                const match = window.location.hostname.match(/([^-]+-[^-]+-[^.]+)\.github\.dev/);
                if (match) {
                  codespaceName = match[1];
                  console.log("Auto-detected codespace name from URL:", codespaceName);
                }
              } else if (window.location.hostname.includes('app.github.dev')) {
                // Handle app.github.dev URLs
                const match = window.location.hostname.match(/([^.]+)\.app\.github\.dev/);
                if (match) {
                  codespaceName = match[1];
                  console.log("Auto-detected codespace name from app URL:", codespaceName);
                }
              }
            }

            console.log("Attempting to connect to VS Code Insiders via bridge extension:");
            console.log("- Codespace name:", codespaceName);
            console.log("- File to open:", currentPath);
            console.log("- Auto-detect enabled:", config.autoDetect);

            // Provide user feedback
            const originalText = editCodespaceBtn.textContent;
            editCodespaceBtn.textContent = "Connecting...";
            editCodespaceBtn.disabled = true;

            // Try to communicate with VS Code extension via HTTP
            openFileInVSCodeInsiders(currentPath, config)
              .then(() => {
                console.log("‚úÖ Successfully sent request to VS Code Insiders");
                editCodespaceBtn.textContent = "Opened!";
                setTimeout(() => {
                  editCodespaceBtn.textContent = originalText;
                  editCodespaceBtn.disabled = false;
                }, 2000);
              })
              .catch((error) => {
                console.error("‚ùå Failed to connect to VS Code Insiders:", error);

                // Fallback to URI scheme method
                console.log("üîÑ Falling back to URI scheme method...");
                const workspaceUrl = `vscode-insiders://vscode-remote/codespaces%2B${codespaceName}/workspaces/${config.repoName}`;
                window.open(workspaceUrl, '_blank');

                editCodespaceBtn.textContent = "Opened (Fallback)";
                setTimeout(() => {
                  editCodespaceBtn.textContent = originalText;
                  editCodespaceBtn.disabled = false;
                }, 3000);
              });
          });
        }

        // Function to communicate with VS Code extension
        async function openFileInVSCodeInsiders(filePath, config) {
          const bridgeUrl = 'http://localhost:3847/open-file';

          // Detect if we're in a codespace or local environment
          const isCodespace = window.location.hostname.includes('github.dev') ||
            window.location.hostname.includes('app.github.dev');

          let workspacePath, fullFilePath;

          if (isCodespace) {
            // Codespace paths
            workspacePath = `/workspaces/${config.repoName}`;
            fullFilePath = `/workspaces/${config.repoName}/${filePath}`;
          } else {
            // Local development paths - use configured local workspace path
            workspacePath = `${config.localWorkspacePath}/${config.repoName}`;
            fullFilePath = `${config.localWorkspacePath}/${config.repoName}/${filePath}`;
          }

          const requestData = {
            filePath: fullFilePath,
            workspacePath: workspacePath,
            repoName: config.repoName,
            originalPath: filePath,
            isCodespace: isCodespace,
            environment: isCodespace ? 'codespace' : 'local'
          };

          console.log("Sending request to VS Code bridge:", requestData);
          console.log("Environment detected:", isCodespace ? 'GitHub Codespace' : 'Local Development');
          console.log("Workspace path:", workspacePath);
          console.log("File path:", fullFilePath);

          const response = await fetch(bridgeUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
          });

          if (!response.ok) {
            throw new Error(`Bridge request failed: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          console.log("Bridge response:", result);

          if (!result.success) {
            throw new Error(result.error || 'Unknown error from bridge');
          }

          return result;
        }

        // Add keyboard shortcut for codespace editing (Ctrl/Cmd + E)
        document.addEventListener('keydown', function (e) {
          if ((e.ctrlKey || e.metaKey) && e.key === 'e' && !e.shiftKey && !e.altKey) {
            // Prevent default browser behavior
            e.preventDefault();

            // Trigger the codespace button if it exists and is enabled
            if (editCodespaceBtn && !editCodespaceBtn.disabled) {
              editCodespaceBtn.click();
            }
          }
        });
      });

      // Navigation functionality
      async function initializeNavigation() {
        const backBtn = document.getElementById('backBtn');
        const nextBtn = document.getElementById('nextBtn');

        if (!backBtn || !nextBtn) return;

        try {
          // Load files.json
          const response = await fetch('/assets/files.json');
          const files = await response.json();

          // Get current page path
          const currentPath = window.location.pathname;

          // Sort files exactly like the sidebar does
          const naturalSort = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;

          // Build file tree structure like sidebar
          function buildFileTree(files) {
            const tree = {};
            const flatList = [];

            files.forEach(file => {
              const parts = file.dir.split('/').filter(p => p);
              let current = tree;

              parts.forEach(part => {
                if (!current[part]) {
                  current[part] = { _files: [], _folders: {} };
                }
                current = current[part]._folders;
              });

              // Add file to the current folder
              const parentParts = parts.length > 0 ? parts : ['root'];
              let parent = tree;
              for (let i = 0; i < parts.length - 1; i++) {
                parent = parent[parts[i]]._folders;
              }
              if (parts.length > 0) {
                const lastPart = parts[parts.length - 1];
                if (!parent[lastPart]) {
                  parent[lastPart] = { _files: [], _folders: {} };
                }
                parent[lastPart]._files.push(file);
              } else {
                if (!tree['root']) {
                  tree['root'] = { _files: [], _folders: {} };
                }
                tree['root']._files.push(file);
              }
            });

            return tree;
          }

          // Render tree to flat list in sidebar order
          function renderTreeToFlatList(tree, level = 0) {
            let flatList = [];

            // Sort folders naturally
            Object.keys(tree).sort(naturalSort).forEach(key => {
              if (key === 'root') return;

              const node = tree[key];

              // Add files in this folder, sorted naturally
              if (node._files && node._files.length > 0) {
                node._files.sort((a, b) => naturalSort(a.name, b.name));
                flatList.push(...node._files);
              }

              // Recursively add files from subfolders
              if (Object.keys(node._folders).length > 0) {
                flatList.push(...renderTreeToFlatList(node._folders, level + 1));
              }
            });

            // Root level files
            if (tree['root'] && tree['root']._files) {
              tree['root']._files.sort((a, b) => naturalSort(a.name, b.name));
              flatList.push(...tree['root']._files);
            }

            return flatList;
          }

          // Build tree and get flat list in sidebar order
          const tree = buildFileTree(files);
          const sortedFiles = renderTreeToFlatList(tree);

          // Find current page index in sorted files array
          let currentIndex = -1;
          for (let i = 0; i < sortedFiles.length; i++) {
            if (sortedFiles[i].path === currentPath) {
              currentIndex = i;
              break;
            }
          }

          // If current page not found, disable navigation
          if (currentIndex === -1) {
            backBtn.disabled = true;
            nextBtn.disabled = true;
            return;
          }

          // Set up back button
          if (currentIndex > 0) {
            const prevFile = sortedFiles[currentIndex - 1];
            backBtn.disabled = false;
            backBtn.addEventListener('click', () => {
              // Scroll to previous file in sidebar before navigation
              scrollToFileInSidebar(prevFile.path);
              window.location.href = prevFile.path;
            });
          } else {
            backBtn.disabled = true;
          }

          // Set up next button
          if (currentIndex < sortedFiles.length - 1) {
            const nextFile = sortedFiles[currentIndex + 1];
            nextBtn.disabled = false;
            nextBtn.addEventListener('click', () => {
              // Scroll to next file in sidebar before navigation
              scrollToFileInSidebar(nextFile.path);
              window.location.href = nextFile.path;
            });
          } else {
            nextBtn.disabled = true;
          }

        } catch (error) {
          console.error('Error loading navigation:', error);
          backBtn.disabled = true;
          nextBtn.disabled = true;
        }
      }

      // Function to scroll to a specific file in the sidebar
      function scrollToFileInSidebar(targetPath) {
        const sidebarContent = document.querySelector('.sidebar-content');
        if (!sidebarContent) return;

        // Find the link for the target file
        const normalize = (p) => decodeURIComponent(p).replace(/\/$/, "").replace(/\.(html|md)$/, "");
        const normalizedTargetPath = normalize(targetPath);

        const links = Array.from(document.querySelectorAll('.file-link'));
        const targetLink = links.find(link => {
          const linkPath = normalize(new URL(link.href).pathname);
          return linkPath === normalizedTargetPath;
        });

        if (targetLink) {
          // Expand parent folders to ensure the link is visible
          let parent = targetLink.closest('details');
          while (parent) {
            parent.open = true;
            parent = parent.parentElement.closest('details');
          }

          // Smooth scroll to the target link
          setTimeout(() => {
            targetLink.scrollIntoView({
              behavior: 'smooth',
              block: 'center',
              inline: 'nearest'
            });
          }, 100); // Small delay to allow folders to expand
        }
      }

      // Initialize navigation when DOM is loaded
      document.addEventListener('DOMContentLoaded', initializeNavigation);
    </script>
    <!-- Offline Manager Modal -->
    <dialog id="offlineModal"
      style="border: none; border-radius: 12px; padding: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); max-width: 400px; width: 90%;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin: 0;">Offline Content</h3>
        <button id="closeOfflineModal"
          style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
      </div>

      <p style="color: #666; font-size: 0.9rem; margin-bottom: 20px;">
        Download the entire site to read without internet.
      </p>

      <div style="display: flex; flex-direction: column; gap: 10px;">
        <button id="syncAllBtn" class="nav-btn"
          style="padding: 10px; background-color: #e8f5e9; color: #1b5e20; border: 1px solid #4caf50;">
          üì• Make Available Offline
        </button>

        <button id="updateBtn" class="nav-btn"
          style="padding: 10px; background-color: #e3f2fd; color: #0d47a1; border: 1px solid #2196f3;">
          üîÑ Check for Updates
        </button>

        <button id="clearCacheBtn" class="nav-btn"
          style="padding: 10px; background-color: #ffebee; color: #c62828; border: 1px solid #ef5350;">
          üóëÔ∏è Clear Offline Data
        </button>
      </div>

      <div id="syncStatus" style="margin-top: 15px; font-size: 0.85rem; color: #555; min-height: 20px;"></div>
      <progress id="syncProgress" value="0" max="100" style="width: 100%; display: none; margin-top: 5px;"></progress>
    </dialog>

    <!-- PWA & Sync Logic -->
    <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
          .then(reg => console.log('SW Registered!', reg))
          .catch(err => console.error('SW Registration failed', err));

        navigator.serviceWorker.addEventListener('message', event => {
          const statusEl = document.getElementById('syncStatus');
          const progressEl = document.getElementById('syncProgress');

          if (event.data.type === 'SYNC_START') {
            statusEl.textContent = `Downloading ${event.data.count} files...`;
            progressEl.style.display = 'block';
            progressEl.value = 0;
          } else if (event.data.type === 'SYNC_PROGRESS') {
            const pct = Math.round((event.data.current / event.data.total) * 100);
            statusEl.textContent = `Downloading... ${event.data.current}/${event.data.total} (${pct}%)`;
            progressEl.value = pct;
          } else if (event.data.type === 'SYNC_COMPLETE') {
            statusEl.textContent = '‚úÖ Offline Ready! (Detailed)';
            progressEl.style.display = 'none';
            localStorage.setItem('lastSync', Date.now());
          } else if (event.data.type === 'CACHE_CLEARED') {
            statusEl.textContent = 'üóëÔ∏è Offline data cleared.';
            localStorage.removeItem('lastSync');
          }
        });
      }

      // Modal Logic
      const offlineBtn = document.getElementById('offlineBtn');
      const offlineModal = document.getElementById('offlineModal');
      const closeOfflineModal = document.getElementById('closeOfflineModal');

      if (offlineBtn && offlineModal) {
        offlineBtn.addEventListener('click', () => offlineModal.showModal());
        closeOfflineModal.addEventListener('click', () => offlineModal.close());

        // Close on click outside
        offlineModal.addEventListener('click', (e) => {
          if (e.target === offlineModal) offlineModal.close();
        });
      }

      // Button Actions
      const syncAllBtn = document.getElementById('syncAllBtn');
      if (syncAllBtn) syncAllBtn.addEventListener('click', async () => {
        startSync(false);
      });

      const updateBtn = document.getElementById('updateBtn');
      if (updateBtn) updateBtn.addEventListener('click', async () => {
        startSync(true); // True = incremental update
      });

      const clearCacheBtn = document.getElementById('clearCacheBtn');
      if (clearCacheBtn) clearCacheBtn.addEventListener('click', () => {
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_CACHE' });
        }
      });

      async function startSync(isUpdate) {
        const statusEl = document.getElementById('syncStatus');
        statusEl.textContent = "Fetching file list...";

        try {
          const response = await fetch('/assets/files.json?t=' + Date.now());
          const files = await response.json();

          let urlsToCache = files.map(f => f.path);

          // Add infrastructure files manually (optional, but good for app shell)
          // Ideally the SW caches these on visit, but pre-caching is safer.
          urlsToCache.push('/', '/assets/files.json', '/login.html');

          if (isUpdate) {
            const lastSync = localStorage.getItem('lastSync') || 0;
            // Filter by mtime if available, else assume new
            const updateCandidates = files.filter(f => !f.mtime || (f.mtime * 1000) > lastSync);

            if (updateCandidates.length === 0) {
              statusEl.textContent = "‚úÖ Up to date.";
              return;
            }
            urlsToCache = updateCandidates.map(f => f.path);
            statusEl.textContent = `Found ${urlsToCache.length} new files...`;
          }

          if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({
              type: 'PRECACHE_ALL',
              urls: urlsToCache
            });
          } else {
            statusEl.textContent = "‚ö†Ô∏è Service Worker not ready. Reload page.";
          }
        } catch (err) {
          console.error(err);
          statusEl.textContent = "‚ùå Error fetching file list.";
        }
      }
    </script>
</body>

</html>