# All subsequence with a target sum

https://leetcode.com/problems/combination-sum/description/

1. You can take an element any number of times
2. Return the number of combinations possible, given a vector of positive numbers

```cpp

void f(vector<int> &tmp, vector<vector<int>> &ans, vector<int> &v, int k, int idx){
    if(k==0){
        ans.push_back(tmp);
        return;
    }
    if(k<0 or idx<0){
       return ;             
    }
    tmp.push_back(v[idx]);
    f(tmp,ans,v,k-v[idx],idx);
    tmp.pop_back();

    f(tmp,ans,v,k,idx-1);
    
}

vector<vector<int>> combinationSum(vector<int> &v, int k){
    vector<vector<int>> ans;
    vector<int> tmp;
    int n=v.size();
    f(tmp,ans,v,k,n-1);
    return ans;    
}

```

https://leetcode.com/problems/combination-sum-ii/description
1. Contain repetitions
2. any number can be took only once

```cpp
void f(vector<int> &tmp, vector<vector<int>> &ans, vector<int> &v, int k, int idx){
    if(k==0){
        ans.push_back(tmp);
        return;
    }
    if(k<0 or idx<0){
       return ;             
    }

    //pick
    tmp.push_back(v[idx]);
    f(tmp,ans,v,k-v[idx],idx-1);
    tmp.pop_back();

    //when not pick, then not pick
    //any of the occurrence 
    int val=v[idx];
    while(idx<v.size() and v[idx]==val){
        idx--;
    }
    f(tmp,ans,v,k,idx);
}

vector<vector<int>> combinationSum2(vector<int> &v, int k){
    vector<vector<int>> ans;
    vector<int> tmp;
    int n=v.size();
    sort(v.begin(),v.end());
    f(tmp,ans,v,k,n-1);
    return ans;    
}


```