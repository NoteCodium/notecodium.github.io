# BST from Tree

# DO IT

https://www.geeksforgeeks.org/problems/largest-bst/1

You're given a binary tree. Your task is to find the size of the largest subtree within this binary tree that also satisfies the properties of a Binary Search Tree (BST). The size of a subtree is defined as the number of nodes it contains.

```
struct Node {
    int data;
    Node *left;
    Node *right;

    Node(int val) {
        data = val;
        left = right = NULL;
    }
};*/

class Solution {
  public:
    /*You are required to complete this method */
    // Return the size of the largest sub-tree which is also a BST
    int largestBst(Node *root) {
        // Your code here
        
    }
};
```

single node is a bst 

![image.png](/images/image-349.png)

![image.png](/images/image-347.png)

![image.png](/images/image-350.png)

![image.png](/images/image-351.png)

![image.png](/images/image-352.png)

```cpp
struct Node {
    int data;
    Node *left;
    Node *right;

    Node(int val) {
        data = val;
        left = right = NULL;
    }
};*/

class Solution {
  public:

    struct SubTreeDetails{
        bool isBST;
        long minn;
        long maxx;
        long cntNodes;
        SubTreeDetails(bool flag, long minVal, long maxVal, long cnt){
             isBST=flag;
             minn=minVal;
             maxx=maxVal;
             cntNodes=cnt;
        }
    };
    
    SubTreeDetails* getLargestBST(Node* node, int &ans){
        if(!node){
            return new SubTreeDetails(1,LONG_MAX,LONG_MIN,0);
        }
        SubTreeDetails* lst= getLargestBST(node->left,ans);
        SubTreeDetails* rst= getLargestBST(node->right,ans);
        bool isBST=0;
        int cnt=1+lst->cntNodes+rst->cntNodes;
        if(lst->isBST and rst->isBST and (node->data>lst->maxx and node->data<rst->minn)){
            ans=max(ans,cnt);
            isBST=1;
        }
        
        long minn= min({(long)node->data,lst->minn,rst->minn}); 
        long maxx= max({(long)node->data,lst->maxx,rst->maxx}); 
        return new SubTreeDetails(isBST,minn,maxx,cnt);
    }

    int largestBst(Node *root) {
        int ans=0;
        getLargestBST(root,ans);
        return ans;
    }
};
```

what is this?

```cpp
// vector<long> t(TreeNode* node){
//     if(!node){
//         return {LONG_MAX,LONG_MIN,1};
//     } 
//     if(!node->left and !node->right){
//         return {node->val,node->val,1};            
//     }

//     auto l=t(node->left);
//     auto r=t(node->right);
//     bool flag=l[2] and r[2] and node->val>l[1] and node->val<r[0];
//     long minn=min(l[0],(long)node->val);
//     long maxx=max(r[1],(long)node->val);
//     return {minn,maxx,flag};

// }

// bool isValidBST(TreeNode* root) {
//     return t(root)[2];
// }
```

https://leetcode.com/problems/recover-binary-search-tree/description/

You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.





