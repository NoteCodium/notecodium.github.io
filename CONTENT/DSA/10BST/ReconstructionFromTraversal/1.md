# From preorder without nulls

![image.png](/images/image-353.png)

![image.png](/images/image-354.png)

![image.png](/images/image-355.png)

By figuring out the nearest greatest element 

![image.png](/images/image-356.png)

![image.png](/images/image-357.png)

![image.png](/images/image-358.png)

![image.png](/images/image-359.png)

![image.png](/images/image-360.png)

![image.png](/images/image-361.png)



Yes, for a given Preorder Traversal, the Binary Search Tree (BST) produced is unique.

```cpp
    vector<int> constructNGE(vector<int>& v, int n){
        stack<int> st;
        st.push(0);
        vector<int> nge(n,n);
        for(int i=1;i<n;i++){
            while(!st.empty() and v[i]>v[st.top()]){
            //as long as it is greater then the top element of stack, it will be nge of that element
                nge[st.top()]=i;
                st.pop();
            }
            st.push(i);
        }
        return nge;
    }


    TreeNode* makeBST(vector<int>& v, int i, int j, vector<int>& nge){
        if(i>j){
            return nullptr;
        }
        TreeNode* node= new TreeNode(v[i],nullptr,nullptr);
        node->left=makeBST(v,i+1,nge[i]-1,nge);
        node->right=makeBST(v,nge[i],j,nge);
        return node;
    }

    TreeNode* bstFromPreorder(vector<int>& v) {
        int n=v.size();
        if(n==0){
            return nullptr;
        }
        vector<int> nge= constructNGE(v,n);
        return makeBST(v,0,n-1,nge);
    }


```

# Without nge array
# FAANG


Hey! Happy to help with BST reconstruction from preorder without NGE.

Direct answer: use a single-pass recursive build that keeps an index pointer and a value bound (upper limit) for the current subtree. At each call, if the current pre[i] is > bound or i==n return NULL; otherwise make pre[i] the root, increment i, recursively build the left subtree with new bound = root value, then build the right subtree with the old bound. This runs in O(N) time and O(N) space (recursion).

Minimal C++ example:

struct TreeNode {
    int val; TreeNode *left, *right;
    TreeNode(int v): val(v), left(nullptr), right(nullptr) {}
};

TreeNode* build(const vector<int>& pre, int& i, int bound) {
    if (i == (int)pre.size() || pre[i] > bound) return nullptr;
    int val = pre[i++]; 
    TreeNode* root = new TreeNode(val);
    root->left  = build(pre, i, val);
    root->right = build(pre, i, bound);
    return root;
}

// caller:
int i = 0;
TreeNode* root = build(preorder, i, INT_MAX);
One key insight: the bound enforces the BST partition (left < root < right) as we consume preorder elements in order, so no scanning or extra array is needed. Want me to walk through a short example (e.g., [8,5,1,7,10,12])?
