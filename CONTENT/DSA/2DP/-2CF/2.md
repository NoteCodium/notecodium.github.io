---
title: 2
---

{% raw %}
https://codeforces.com/problemset/problem/1350/B

# B. Orac and Models

dp[i][j]= standing at idx i such that last element is j

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0001.png)

The answer from here for both the series will be the same.

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0002.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0003.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0004.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0005.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0006.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0007.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0008.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0009.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0010.png)

```python
void solve(){   
    ll lastElem,len;
    inp(lastElem,len);
    //dp state 
    //dp[len][lastElement]
    //base case
    //dp[n][anyValue]=1
    ///answer 
    //dp[0][1]
    //putting a 1 at an invalid idx insures that
    //the first actual index can take any value
    //as all elements are multiple of 1
    vvl dp(len+1,vl(lastElem+1));
    for(ll i=1;i<=lastElem;i++){
        dp[len][i]=1;
    }
    for(int i=len-1;i>=0;i--){
        for(int j=1;j<=lastElem;j++){
            for(int k=j;k<=lastElem;k+=j){
                dp[i][j]=moda(dp[i][j],dp[i+1][k]);
            }
        } 
    }
    pri(dp[0][1]);
}
```

https://cses.fi/problemset/task/1746

# Array Description

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0011.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0012.png)

overlapping subproblems    
![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0013.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0014.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0015.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0016.png)

writing transitions

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0017.png)

![image.png](/DTRANSFER/notebook_images/DTRANSFER_ADCLCHJC_1Algorithms_40DP_-2CF_2__att_0018.png)

```python
int main()  
{
    ll n,limit;
    cin>>n>>limit;
    vfirst(v,n);
    vector<vector<long long>> dp(n,vector<long long> (limit+1,0));
    //dp[idx][x]
    //standing at idx idx and x is the value at idx
 
    //base case
    for(int i=1;i<=limit;i++){
        dp[0][i]= v[0]==0 or v[0] ==i ? 1:0;
    }
 
    //we are only considering prefixes as of now
 
    for(int i=1;i<n;i++){
        for(int j=1;j<=limit;j++){
            //doubt
            if(v[i]==0 or v[i]==j){
                dp[i][j] = dp[i - 1][j];
                if (j - 1 >= 0)
                    dp[i][j] = moda(dp[i - 1][j - 1],dp[i][j]);
                if (j + 1 <= limit)
                    dp[i][j] = moda(dp[i - 1][j + 1],dp[i][j]);
            }
        }
    }
 
    ll ans=0;
    for(int i=1;i<=limit;i++){
        ans=moda(ans,dp[n-1][i]);
    }
 
    cout<<ans<<nl;
 
 
}
```
{% endraw %}
