```
conn.setAutoCommit(false);

//Queries

conn.commit();


//does it work like batch query?
```

```
package com.example.one;

import org.springframework.stereotype.Component;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

@Component
public class ConnectDB {
    void customConnect() throws SQLException {
        Connection conn= DriverManager.getConnection("jdbc:postgresql://localhost:5432/one_database", "tarunmac", "password");
//        However, manually using DriverManager.getConnection(...) is bad practice in Spring Boot for two reasons:
//
//        No Connection Pooling: DriverManager opens a new physical connection every single time the method is called, which is very slow. Spring Boot comes with HikariCP (a high-performance connection pool) by default.

        conn.setAutoCommit(false);


        Statement stmt=conn.createStatement();
				
				//this stmt can be used more then once 
			
        String sql="CREATE TABLE IF NOT EXISTS users (id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100))";
        int cnt1= stmt.executeUpdate(sql);

//        String sqlInsert="INSERT INTO users (name, email) VALUES \n" +
//                "('Tarun Mac', 'tarun@example.com'),\n" +
//                "('Jane Doe', 'jane@test.io'),\n" +
//                "('John Smith', 'john.smith@gmail.com');";
//       int cnt2= stmt.executeUpdate(sqlInsert);
        conn.commit();

        stmt.close();
        conn.close();
    }
}



```

![image.png](/images/image-248.png)

![image.png](/images/image-249.png)

![image.png](/images/image-250.png)

![image.png](/images/image-251.png)

![image.png](/images/image-252.png)

![image.png](/images/image-253.png)

### A statement can be associated with one ResultSet only

![image.png](/images/image-254.png)

![image.png](/images/image-277.png)  

```
 int cnt=stmt.executeUpdate("update one name=two where id=1");
```

```
ResultSet rs=stmt.executeQuery("select * from "+ table );
while(rs.next()){
    System.out.println(rs.getString("id"));
}
//The initial position is just one position before it
//rs.previous() for reverse


execute(colon separated sql string )
//multiple separate sql strings
//It returns a Boolean
//True result is ResultSet
//False (UpdateCount or there are no results)
stmt.getResultSet()

stmt.getUpdateCount()
```

In the above code there will be only one network call 

![image.png](/images/image-289.png)

![image.png](/images/image-290.png)

![image.png](/images/image-291.png)

![image.png](/images/image-292.png)

TODO implement it







# Result set has also a close method

when you close connection statment close and so on 

# Experimenting with my data

![image.png](/images/image-278.png)

users

y default, a JDBC ResultSet is read-only. You can read data from it, but you cannot write changes back to the database through it unless you explicitly configure the Statement to be "Updatable."

The Fix

You need to change how you create the Statement to allow updates.

# Updates with sql

```
        Statement stmtUpdate = conn.createStatement(
                ResultSet.TYPE_SCROLL_INSENSITIVE,
                ResultSet.CONCUR_UPDATABLE  // <--- This enables rs.updateRow()
        );
        ResultSet rs=stmtUpdate.executeQuery("SELECT * FROM users");
        while(rs.next()){
            if(rs.getString("name").equals("Tarun Mac")){
                rs.updateInt("id", 100+rs.getInt("id"));
                rs.updateRow();
            }
        }
```

```
rs.updateString()
```

# Updates without insert

 ![image.png](/images/image-284.png)

```
res.moveToInsertRow();
setValues
rs.insertRow()
rs.moveToCurrentRow()
```

![image.png](/images/image-286.png)